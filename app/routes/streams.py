from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from app.database import get_db
from app.models import Stream, StreamMetadata, Recording, StreamEvent, ActiveRecordingState
from app.services.background_queue_service import background_queue_service
import logging
from pathlib import Path

logger = logging.getLogger("streamvault")

router = APIRouter(
    prefix="/api/streams",
    tags=["streams"]
)

@router.delete("/{stream_id}")
async def delete_stream(
    request: Request,
    stream_id: int,
    db: Session = Depends(get_db)
):
    """Delete a specific stream and all associated metadata"""
    logger.info(f"Request {request.method} {request.url.path}")
    
    try:
        # Check if the stream exists
        stream = db.query(Stream).filter(Stream.id == stream_id).first()
        if not stream:
            raise HTTPException(status_code=404, detail=f"Stream with ID {stream_id} not found")
        
        # Collect all metadata files that need to be deleted
        files_to_delete = []
        
        # Get metadata for this stream
        metadata = db.query(StreamMetadata).filter(StreamMetadata.stream_id == stream.id).first()
        
        if metadata:
            # Collect all metadata files that need to be deleted
            # Only include paths that are actually generated by the system
            for attr in [
                'thumbnail_path',           # Generated by thumbnail service
                'json_path',               # Generated by metadata service
                'nfo_path',                # Generated by metadata service (episode NFO)
                'tvshow_nfo_path',         # Generated by metadata service (tvshow NFO)
                'season_nfo_path',         # Generated by metadata service (season NFO)
                'chapters_vtt_path',       # Generated by metadata service (VTT chapters)
                'chapters_srt_path',       # Generated by metadata service (SRT chapters)
                'chapters_ffmpeg_path',    # Generated by metadata service (FFmpeg chapters)
                'chapters_xml_path'        # Generated by metadata service (XML chapters)
            ]:
                path = getattr(metadata, attr, None)
                if path:
                    files_to_delete.append(path)
                    
            # Delete metadata record (foreign key constraint)
            db.delete(metadata)
        
        # Check for recordings associated with this stream and collect their paths
        recordings = db.query(Recording).filter(Recording.stream_id == stream.id).all()
        for recording in recordings:
            if recording.path:
                files_to_delete.append(recording.path)
                
                # Also check for related files (.ts, .mp4, segment directories)
                file_path_obj = Path(recording.path)
                
                # Check for .ts version if we have .mp4
                if file_path_obj.suffix == '.mp4':
                    ts_version = file_path_obj.with_suffix('.ts')
                    if ts_version.exists():
                        files_to_delete.append(str(ts_version))
                
                # Check for .mp4 version if we have .ts
                elif file_path_obj.suffix == '.ts':
                    mp4_version = file_path_obj.with_suffix('.mp4')
                    if mp4_version.exists():
                        files_to_delete.append(str(mp4_version))
                
                # Check for segment directories
                segments_dir = file_path_obj.parent / f"{file_path_obj.stem}_segments"
                if segments_dir.exists() and segments_dir.is_dir():
                    files_to_delete.append(str(segments_dir))
            
            # Delete recording record
            db.delete(recording)
        
        # Also check the stream's recording_path
        if stream.recording_path:
            files_to_delete.append(stream.recording_path)
            
            # Check for related files for the stream's recording_path too
            stream_file = Path(stream.recording_path)
            
            # Check for .ts version if we have .mp4
            if stream_file.suffix == '.mp4':
                ts_version = stream_file.with_suffix('.ts')
                if ts_version.exists():
                    files_to_delete.append(str(ts_version))
            
            # Check for .mp4 version if we have .ts
            elif stream_file.suffix == '.ts':
                mp4_version = stream_file.with_suffix('.mp4')
                if mp4_version.exists():
                    files_to_delete.append(str(mp4_version))
            
            # Check for segment directories
            segments_dir = stream_file.parent / f"{stream_file.stem}_segments"
            if segments_dir.exists() and segments_dir.is_dir():
                files_to_delete.append(str(segments_dir))
        
        # Delete all stream events for this stream
        db.query(StreamEvent).filter(StreamEvent.stream_id == stream.id).delete()
        
        # Delete active recording state for this stream
        db.query(ActiveRecordingState).filter(ActiveRecordingState.stream_id == stream.id).delete()
        
        # Delete the stream record itself
        db.delete(stream)
        
        # Commit all database deletions
        db.commit()
        
        # Schedule file deletion in background
        if files_to_delete:
            # Remove duplicates while preserving order
            unique_files = list(dict.fromkeys(files_to_delete))
            
            background_queue = background_queue_service
            await background_queue.enqueue_task(
                "cleanup",
                {
                    "cleanup_paths": unique_files,
                    "stream_id": stream_id
                }
            )
        
        return {
            "success": True,
            "message": f"Stream {stream_id} deleted successfully",
            "deleted_files_count": len(unique_files) if files_to_delete else 0
        }
        
    except Exception as e:
        logger.error(f"Error deleting stream {stream_id}: {e}", exc_info=True)
        db.rollback()
        raise HTTPException(status_code=500, detail="Failed to delete stream. Please try again.")
